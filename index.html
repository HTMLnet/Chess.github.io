<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VASCII v2.0</title>
</head>
<body>
<center>
<h1>VASCII v2.0</h1>

<label>Theme: 
<select id="themeSelect">
  <option value="light">Light Mode</option>
  <option value="dark">Dark Mode</option>
</select>
</label>
<br><br>

<canvas id="canvas" width="500" height="200" style="border:1px solid #000"></canvas>
<br>
<input type="file" id="audioFile" accept="audio/*">
<button id="recordBtn">Start Recording</button>
<br><br>
<label>Choose Preset: 
<select id="presetSelect"></select>
</label>
<p id="status">Status: Waiting</p>

<details>
  <summary>Controls / Guide</summary>
  <ul style="text-align:left; display:inline-block; margin-top:5px;">
    <li>1 = Happy</li>
    <li>2 = Angry</li>
    <li>3 = Surprised</li>
    <li>0 = Neutral</li>
    <li>Hold Space = Talk</li>
    <li>Load an audio file → Start Recording → Download WebM</li>
    <li>Choose Preset from dropdown</li>
    <li>Create custom presets below</li>
    <li>Switch theme with dropdown</li>
  </ul>
</details>

<h3>Create Custom Preset</h3>
<form id="customPresetForm">
  Name: <input type="text" id="presetName" required><br>
  Neutral: <input type="text" id="neutralFace" required><br>
  Happy: <input type="text" id="happyFace" required><br>
  Angry: <input type="text" id="angryFace" required><br>
  Surprised: <input type="text" id="surprisedFace" required><br>
  Blink: <input type="text" id="blinkFace" required><br>
  Talk 1: <input type="text" id="talk1Face" required><br>
  Talk 2: <input type="text" id="talk2Face" required><br>
  <button type="submit">Save Preset</button>
</form>
<br>
<button id="exportPresetBtn">Export Current Preset</button>
<br><br>
<select id="deletePresetSelect">
  <option value="">--Select custom preset--</option>
</select>
<button id="confirmDeleteBtn">Delete</button>
<br>
<input type="file" id="importPresetFile" accept=".txt">
</center>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const audioInput = document.getElementById('audioFile');
const recordBtn = document.getElementById('recordBtn');
const presetSelect = document.getElementById('presetSelect');
const status = document.getElementById('status');
const deleteSelect = document.getElementById('deletePresetSelect');
const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
const themeSelect = document.getElementById('themeSelect');

let presets = {
  ascii: {neutral:'/(\u00B0-\u00B0)\\', happy:'/(\u00B0o\u00B0)\\', angry:'/(\u003E_<)\\', surprised:'/(\u004F_\u004F)\\', blink:'/(-_-)\\', talk1:'/(\u00B0o\u00B0)\\', talk2:'/(\u00B0-\u00B0)\\'},
  emojiboy:{neutral:'😐', happy:'😆', angry:'😠', surprised:'😮', blink:'😑', talk1:'😆', talk2:'😐'},
  mitten:{neutral:'😺', happy:'😸', angry:'😾', surprised:'🙀', blink:'😿', talk1:'😸', talk2:'😺'},
  bluedude:{neutral:'👤', happy:'🗣️', angry:'👤', surprised:'🗣️', blink:'👤', talk1:'🗣️', talk2:'👤'},
  moon:{neutral:'🌚', happy:'🌝', angry:'🌚', surprised:'🌝', blink:'🌚', talk1:'🌝', talk2:'🌚'},
  classic:{neutral:'[-_-]', happy:'[^_^]', angry:'[>_<]', surprised:'[O_O]', blink:'[-_-]', talk1:'[^_^]', talk2:'[-_-]'},
  sniper:{neutral:'▄︻デ══━一', happy:'▄︻デ══━一💥', angry:'▄︻デ══━一', surprised:'▄︻デ══━一💥', blink:'▄︻デ══━一', talk1:'▄︻デ══━一💥', talk2:'▄︻デ══━一'},
  rain:{neutral:'☁️', happy:'🌧️', angry:'⛈️', surprised:'🌩️', blink:'☁️', talk1:'🌧️', talk2:'☁️'},
  teacher:{neutral:'/(°-°)\\', happy:'/(°o°)\\', angry:'/(>_<)\\', surprised:'/(O_O)\\', blink:'/(-_-)\\', talk1:'/(°o°)ノ', talk2:'/(°o°)—'}
};

let savedCustom = JSON.parse(localStorage.getItem('vtuber_presets') || '{}');
Object.assign(presets, savedCustom);

let currentPreset = presets['ascii'];
let currentFace = currentPreset.neutral;
let talking=false;
let talkingToggle=false;
let blinkTimeout;
let audioContext, analyser, source, dataArray, freqArray, audioElement;
let recorder, chunks=[], animationId;
let isSpaceDown=false;

function drawFace(){
  let bgColor = themeSelect.value==='dark' ? 'black' : 'white';
  let textColor = themeSelect.value==='dark' ? 'white' : 'black';
  ctx.fillStyle = bgColor;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = textColor;
  ctx.font='32px monospace';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  let faceToDraw=currentFace;
  if(talking) faceToDraw = talkingToggle ? currentPreset.talk1 : currentPreset.talk2;
  ctx.fillText(faceToDraw, canvas.width/2, canvas.height/2);
}

themeSelect.addEventListener('change', drawFace);

function animate(){
  drawFace();
  if(talking) talkingToggle = !talkingToggle;
  animationId = setTimeout(animate,300);
}

function startBlinkCycle(){
  clearTimeout(blinkTimeout);
  const delay = 5000 + Math.random()*5000;
  blinkTimeout=setTimeout(()=>{
    if(!talking && !isSpaceDown && currentFace===currentPreset.neutral){
      currentFace=currentPreset.blink;
      drawFace();
      setTimeout(()=>{if(currentFace===currentPreset.blink) currentFace=currentPreset.neutral; drawFace();},500);
    }
    startBlinkCycle();
  },delay);
}

function analyzeAudio(){
  analyser.getByteTimeDomainData(dataArray);
  analyser.getFloatFrequencyData(freqArray);

  let sum=0; for(let i=0;i<dataArray.length;i++){let v=(dataArray[i]-128)/128;sum+=v*v;}
  let rms=Math.sqrt(sum/dataArray.length);
  talking = rms>0.05 || isSpaceDown;

  let maxFreq=-Infinity,index=0;
  for(let i=0;i<freqArray.length;i++){if(freqArray[i]>maxFreq){maxFreq=freqArray[i]; index=i;}}
  let freq = index * audioContext.sampleRate / analyser.fftSize;
  if(talking){
    if(freq>600) currentFace=currentPreset.happy;
    else if(freq>200) currentFace=currentPreset.neutral;
    else currentFace=currentPreset.angry;
  } else {
    if(!isSpaceDown && !currentFace.startsWith('/(')) currentFace=currentPreset.neutral;
  }
  requestAnimationFrame(analyzeAudio);
}

function populateDropdown(){
  presetSelect.innerHTML='';
  for(let key in presets){
    let option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    presetSelect.appendChild(option);
  }
  currentPreset = presets[presetSelect.value];
}

function updateDeleteDropdown(){
  deleteSelect.innerHTML = '<option value="">--Select custom preset--</option>';
  for(let key in savedCustom){
    const option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    deleteSelect.appendChild(option);
  }
}

populateDropdown();
updateDeleteDropdown();

audioInput.addEventListener('change', e=>{
  if(!e.target.files[0]) return;
  if(audioElement) audioElement.pause();
  audioElement=new Audio(URL.createObjectURL(e.target.files[0]));
  audioElement.crossOrigin="anonymous";
  audioElement.load();
  if(audioContext) audioContext.close();
  audioContext=new (window.AudioContext || window.webkitAudioContext)();
  source=audioContext.createMediaElementSource(audioElement);
  analyser=audioContext.createAnalyser();
  analyser.fftSize=2048;
  dataArray=new Uint8Array(analyser.fftSize);
  freqArray=new Float32Array(analyser.frequencyBinCount);
  source.connect(analyser);
  analyser.connect(audioContext.destination);
  status.textContent='Status: Audio loaded';
});

recordBtn.addEventListener('click', ()=>{
  if(!audioElement){ alert('Load an audio file first'); return; }
  chunks=[];
  const canvasStream=canvas.captureStream(30);
  const audioStream=audioElement.captureStream();
  const combined=new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]);

  recorder=new MediaRecorder(combined,{mimeType:'video/webm;codecs=vp8,opus'});
  recorder.ondataavailable=e=>chunks.push(e.data);
  recorder.onstop=()=>{
    const blob=new Blob(chunks,{type:'video/webm'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='vtuber_video.webm';
    a.click();
    status.textContent='Status: Video ready to download';
  };

  animate();
  startBlinkCycle();
  recorder.start();
  audioElement.play();
  analyzeAudio();
  status.textContent='Status: Recording...';

  audioElement.onended=()=>{
    clearTimeout(animationId);
    clearTimeout(blinkTimeout);
    recorder.stop();
    currentFace=currentPreset.neutral;
    drawFace();
  };
});

presetSelect.addEventListener('change', e=>{
  currentPreset = presets[e.target.value];
  currentFace = currentPreset.neutral;
  drawFace();
});

document.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==='1') currentFace=currentPreset.happy;
  else if(e.key==='2') currentFace=currentPreset.angry;
  else if(e.key==='3') currentFace=currentPreset.surprised;
  else if(e.key==='0') currentFace=currentPreset.neutral;
  else if(e.code==='Space'){ e.preventDefault(); isSpaceDown=true; talking=true; }
});
document.addEventListener('keyup', e=>{
  if(e.code==='Space'){ isSpaceDown=false; talking=false; currentFace=currentPreset.neutral; }
});

// Custom preset form
document.getElementById('customPresetForm').addEventListener('submit', e=>{
  e.preventDefault();
  const name = document.getElementById('presetName').value.trim();
  if(!name) return;
  const newPreset = {
    neutral: document.getElementById('neutralFace').value,
    happy: document.getElementById('happyFace').value,
    angry: document.getElementById('angryFace').value,
    surprised: document.getElementById('surprisedFace').value,
    blink: document.getElementById('blinkFace').value,
    talk1: document.getElementById('talk1Face').value,
    talk2: document.getElementById('talk2Face').value
  };
  presets[name] = newPreset;
  savedCustom[name] = newPreset;
  localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
  populateDropdown();
  updateDeleteDropdown();
  presetSelect.value = name;
  currentPreset = newPreset;
  currentFace = currentPreset.neutral;
  drawFace();
});

// Export preset
document.getElementById('exportPresetBtn').addEventListener('click', ()=>{
  const data = JSON.stringify(currentPreset, null, 2);
  const blob = new Blob([data], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = currentPreset.name ? currentPreset.name+'.txt' : 'preset.txt';
  a.click();
});

// Import preset
document.getElementById('importPresetFile').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try{
      const imported = JSON.parse(evt.target.result);
      const name = file.name.replace('.txt','');
      presets[name] = imported;
      savedCustom[name] = imported;
      localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
      populateDropdown();
      updateDeleteDropdown();
      presetSelect.value = name;
      currentPreset = imported;
      currentFace = currentPreset.neutral;
      drawFace();
    }catch(err){ alert('Invalid preset file'); }
  };
  reader.readAsText(file);
});

// Delete custom preset with submit button
confirmDeleteBtn.addEventListener('click', ()=>{
  const key = deleteSelect.value;
  if(!key) { alert('Please select a custom preset to delete'); return; }
  if(confirm(`Are you sure you want to delete custom preset "${key}"?`)){
    delete presets[key];
    delete savedCustom[key];
    localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
    populateDropdown();
    updateDeleteDropdown();
    currentPreset = presets['ascii'];
    presetSelect.value = 'ascii';
    currentFace = currentPreset.neutral;
    drawFace();
  }
});
</script>
</body>
</html>    <li>Load an audio file → Start Recording → Download WebM</li>
    <li>Choose Preset from dropdown</li>
    <li>Create custom presets below</li>
    <li>Switch theme with dropdown</li>
  </ul>
</details>

<h3>Create Custom Preset</h3>
<form id="customPresetForm">
  Name: <input type="text" id="presetName" required><br>
  Neutral: <input type="text" id="neutralFace" required><br>
  Happy: <input type="text" id="happyFace" required><br>
  Angry: <input type="text" id="angryFace" required><br>
  Surprised: <input type="text" id="surprisedFace" required><br>
  Blink: <input type="text" id="blinkFace" required><br>
  Talk 1: <input type="text" id="talk1Face" required><br>
  Talk 2: <input type="text" id="talk2Face" required><br>
  <button type="submit">Save Preset</button>
</form>
<br>
<button id="exportPresetBtn">Export Current Preset</button>
<br><br>
<select id="deletePresetSelect">
  <option value="">--Select custom preset--</option>
</select>
<button id="confirmDeleteBtn">Delete</button>
<br>
<input type="file" id="importPresetFile" accept=".txt">
</center>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const audioInput = document.getElementById('audioFile');
const recordBtn = document.getElementById('recordBtn');
const presetSelect = document.getElementById('presetSelect');
const status = document.getElementById('status');
const deleteSelect = document.getElementById('deletePresetSelect');
const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
const themeSelect = document.getElementById('themeSelect');

let presets = {
  ascii: {neutral:'/(\u00B0-\u00B0)\\', happy:'/(\u00B0o\u00B0)\\', angry:'/(\u003E_<)\\', surprised:'/(\u004F_\u004F)\\', blink:'/(-_-)\\', talk1:'/(\u00B0o\u00B0)\\', talk2:'/(\u00B0-\u00B0)\\'},
  emojiboy:{neutral:'😐', happy:'😆', angry:'😠', surprised:'😮', blink:'😑', talk1:'😆', talk2:'😐'},
  mitten:{neutral:'😺', happy:'😸', angry:'😾', surprised:'🙀', blink:'😿', talk1:'😸', talk2:'😺'},
  bluedude:{neutral:'👤', happy:'🗣️', angry:'👤', surprised:'🗣️', blink:'👤', talk1:'🗣️', talk2:'👤'},
  moon:{neutral:'🌚', happy:'🌝', angry:'🌚', surprised:'🌝', blink:'🌚', talk1:'🌝', talk2:'🌚'},
  classic:{neutral:'[-_-]', happy:'[^_^]', angry:'[>_<]', surprised:'[O_O]', blink:'[-_-]', talk1:'[^_^]', talk2:'[-_-]'},
  sniper:{neutral:'▄︻デ══━一', happy:'▄︻デ══━一💥', angry:'▄︻デ══━一', surprised:'▄︻デ══━一💥', blink:'▄︻デ══━一', talk1:'▄︻デ══━一💥', talk2:'▄︻デ══━一'},
  rain:{neutral:'☁️', happy:'🌧️', angry:'⛈️', surprised:'🌩️', blink:'☁️', talk1:'🌧️', talk2:'☁️'},
  teacher:{neutral:'/(°-°)\\', happy:'/(°o°)\\', angry:'/(>_<)\\', surprised:'/(O_O)\\', blink:'/(-_-)\\', talk1:'/(°o°)ノ', talk2:'/(°o°)—'}
};

let savedCustom = JSON.parse(localStorage.getItem('vtuber_presets') || '{}');
Object.assign(presets, savedCustom);

let currentPreset = presets['ascii'];
let currentFace = currentPreset.neutral;
let talking=false;
let talkingToggle=false;
let blinkTimeout;
let audioContext, analyser, source, dataArray, freqArray, audioElement;
let recorder, chunks=[], animationId;
let isSpaceDown=false;

function drawFace(){
  let bgColor = themeSelect.value==='dark' ? 'black' : 'white';
  let textColor = themeSelect.value==='dark' ? 'white' : 'black';
  ctx.fillStyle = bgColor;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = textColor;
  ctx.font='32px monospace';
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  let faceToDraw=currentFace;
  if(talking) faceToDraw = talkingToggle ? currentPreset.talk1 : currentPreset.talk2;
  ctx.fillText(faceToDraw, canvas.width/2, canvas.height/2);
}

themeSelect.addEventListener('change', drawFace);

function animate(){
  drawFace();
  if(talking) talkingToggle = !talkingToggle;
  animationId = setTimeout(animate,300);
}

function startBlinkCycle(){
  clearTimeout(blinkTimeout);
  const delay = 5000 + Math.random()*5000;
  blinkTimeout=setTimeout(()=>{
    if(!talking && !isSpaceDown && currentFace===currentPreset.neutral){
      currentFace=currentPreset.blink;
      drawFace();
      setTimeout(()=>{if(currentFace===currentPreset.blink) currentFace=currentPreset.neutral; drawFace();},500);
    }
    startBlinkCycle();
  },delay);
}

function analyzeAudio(){
  analyser.getByteTimeDomainData(dataArray);
  analyser.getFloatFrequencyData(freqArray);

  let sum=0; for(let i=0;i<dataArray.length;i++){let v=(dataArray[i]-128)/128;sum+=v*v;}
  let rms=Math.sqrt(sum/dataArray.length);
  talking = rms>0.05 || isSpaceDown;

  let maxFreq=-Infinity,index=0;
  for(let i=0;i<freqArray.length;i++){if(freqArray[i]>maxFreq){maxFreq=freqArray[i]; index=i;}}
  let freq = index * audioContext.sampleRate / analyser.fftSize;
  if(talking){
    if(freq>600) currentFace=currentPreset.happy;
    else if(freq>200) currentFace=currentPreset.neutral;
    else currentFace=currentPreset.angry;
  } else {
    if(!isSpaceDown && !currentFace.startsWith('/(')) currentFace=currentPreset.neutral;
  }
  requestAnimationFrame(analyzeAudio);
}

function populateDropdown(){
  presetSelect.innerHTML='';
  for(let key in presets){
    let option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    presetSelect.appendChild(option);
  }
  currentPreset = presets[presetSelect.value];
}

function updateDeleteDropdown(){
  deleteSelect.innerHTML = '<option value="">--Select custom preset--</option>';
  for(let key in savedCustom){
    const option = document.createElement('option');
    option.value = key;
    option.textContent = key;
    deleteSelect.appendChild(option);
  }
}

populateDropdown();
updateDeleteDropdown();

audioInput.addEventListener('change', e=>{
  if(!e.target.files[0]) return;
  if(audioElement) audioElement.pause();
  audioElement=new Audio(URL.createObjectURL(e.target.files[0]));
  audioElement.crossOrigin="anonymous";
  audioElement.load();
  if(audioContext) audioContext.close();
  audioContext=new (window.AudioContext || window.webkitAudioContext)();
  source=audioContext.createMediaElementSource(audioElement);
  analyser=audioContext.createAnalyser();
  analyser.fftSize=2048;
  dataArray=new Uint8Array(analyser.fftSize);
  freqArray=new Float32Array(analyser.frequencyBinCount);
  source.connect(analyser);
  analyser.connect(audioContext.destination);
  status.textContent='Status: Audio loaded';
});

recordBtn.addEventListener('click', ()=>{
  if(!audioElement){ alert('Load an audio file first'); return; }
  chunks=[];
  const canvasStream=canvas.captureStream(30);
  const audioStream=audioElement.captureStream();
  const combined=new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]);

  recorder=new MediaRecorder(combined,{mimeType:'video/webm;codecs=vp8,opus'});
  recorder.ondataavailable=e=>chunks.push(e.data);
  recorder.onstop=()=>{
    const blob=new Blob(chunks,{type:'video/webm'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url;
    a.download='vtuber_video.webm';
    a.click();
    status.textContent='Status: Video ready to download';
  };

  animate();
  startBlinkCycle();
  recorder.start();
  audioElement.play();
  analyzeAudio();
  status.textContent='Status: Recording...';

  audioElement.onended=()=>{
    clearTimeout(animationId);
    clearTimeout(blinkTimeout);
    recorder.stop();
    currentFace=currentPreset.neutral;
    drawFace();
  };
});

presetSelect.addEventListener('change', e=>{
  currentPreset = presets[e.target.value];
  currentFace = currentPreset.neutral;
  drawFace();
});

document.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==='1') currentFace=currentPreset.happy;
  else if(e.key==='2') currentFace=currentPreset.angry;
  else if(e.key==='3') currentFace=currentPreset.surprised;
  else if(e.key==='0') currentFace=currentPreset.neutral;
  else if(e.code==='Space'){ e.preventDefault(); isSpaceDown=true; talking=true; }
});
document.addEventListener('keyup', e=>{
  if(e.code==='Space'){ isSpaceDown=false; talking=false; currentFace=currentPreset.neutral; }
});

// Custom preset form
document.getElementById('customPresetForm').addEventListener('submit', e=>{
  e.preventDefault();
  const name = document.getElementById('presetName').value.trim();
  if(!name) return;
  const newPreset = {
    neutral: document.getElementById('neutralFace').value,
    happy: document.getElementById('happyFace').value,
    angry: document.getElementById('angryFace').value,
    surprised: document.getElementById('surprisedFace').value,
    blink: document.getElementById('blinkFace').value,
    talk1: document.getElementById('talk1Face').value,
    talk2: document.getElementById('talk2Face').value
  };
  presets[name] = newPreset;
  savedCustom[name] = newPreset;
  localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
  populateDropdown();
  updateDeleteDropdown();
  presetSelect.value = name;
  currentPreset = newPreset;
  currentFace = currentPreset.neutral;
  drawFace();
});

// Export preset
document.getElementById('exportPresetBtn').addEventListener('click', ()=>{
  const data = JSON.stringify(currentPreset, null, 2);
  const blob = new Blob([data], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = currentPreset.name ? currentPreset.name+'.txt' : 'preset.txt';
  a.click();
});

// Import preset
document.getElementById('importPresetFile').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try{
      const imported = JSON.parse(evt.target.result);
      const name = file.name.replace('.txt','');
      presets[name] = imported;
      savedCustom[name] = imported;
      localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
      populateDropdown();
      updateDeleteDropdown();
      presetSelect.value = name;
      currentPreset = imported;
      currentFace = currentPreset.neutral;
      drawFace();
    }catch(err){ alert('Invalid preset file'); }
  };
  reader.readAsText(file);
});

// Delete custom preset with submit button
confirmDeleteBtn.addEventListener('click', ()=>{
  const key = deleteSelect.value;
  if(!key) { alert('Please select a custom preset to delete'); return; }
  if(confirm(`Are you sure you want to delete custom preset "${key}"?`)){
    delete presets[key];
    delete savedCustom[key];
    localStorage.setItem('vtuber_presets', JSON.stringify(savedCustom));
    populateDropdown();
    updateDeleteDropdown();
    currentPreset = presets['ascii'];
    presetSelect.value = 'ascii';
    currentFace = currentPreset.neutral;
    drawFace();
  }
});
</script>
</body>
</html>  <script>
    const pieces = {
      r:"♜", n:"♞", b:"♝", q:"♛", k:"♚", p:"♟",
      R:"♖", N:"♘", B:"♗", Q:"♕", K:"♔", P:"♙", ".":""
    };

    let board, turn, mode="2p", selected;

    function reset() {
      board = [
        ["r","n","b","q","k","b","n","r"],
        ["p","p","p","p","p","p","p","p"],
        [".",".",".",".",".",".",".","."],
        [".",".",".",".",".",".",".","."],
        [".",".",".",".",".",".",".","."],
        [".",".",".",".",".",".",".","."],
        ["P","P","P","P","P","P","P","P"],
        ["R","N","B","Q","K","B","N","R"]
      ];
      turn = "white";
      selected = null;
      renderBoard();
    }

    function setMode(m) { mode = m; reset(); }

    function renderBoard(highlights=[]) {
      const grid = document.getElementById("grid");
      grid.innerHTML = "";
      for (let r=0;r<8;r++) {
        for (let c=0;c<8;c++) {
          let div=document.createElement("div");
          div.style.display="flex";
          div.style.alignItems="center";
          div.style.justifyContent="center";
          div.style.fontSize="36px";
          if (highlights.some(h=>h[0]===r&&h[1]===c)&&board[r][c]===".") {
            div.textContent="•";
          } else {
            div.textContent=pieces[board[r][c]];
          }
          div.onclick=()=>handleClick(r,c);
          grid.appendChild(div);
        }
      }
      document.getElementById("status").textContent =
        turn+"'s move" + (mode!=="2p"?" ("+mode+")":"");
    }

    function handleClick(r,c) {
      if (selected) {
        let [sr,sc]=selected;
        if (r===sr&&c===sc) {selected=null; renderBoard(); return;}
        if (getMoves(sr,sc).some(m=>m[0]===r&&m[1]===c)) {
          makeMove(sr,sc,r,c);
          selected=null; return;
        } else {selected=null; renderBoard();}
      } else {
        let piece=board[r][c];
        if (piece===".") return;
        if ((turn==="white"&&piece===piece.toLowerCase())||
            (turn==="black"&&piece===piece.toUpperCase())) return;
        selected=[r,c];
        renderBoard(getMoves(r,c));
      }
    }

    function makeMove(r1,c1,r2,c2) {
      board[r2][c2]=board[r1][c1];
      board[r1][c1]=".";
      turn=(turn==="white"?"black":"white");
      renderBoard();
      if (checkmate(turn)) { triumph(turn==="white"?"Black":"White"); return; }
      if (mode!=="2p" && turn==="black") setTimeout(botMove,300);
    }

    // Triumph
    function triumph(winner) {
      let overlay=document.getElementById("triumph");
      overlay.style.display="flex";
      let chars=["✦","✧","✶","✷","✸","✹"];
      let i=0;
      setInterval(()=>{ overlay.textContent=winner+" Wins! "+chars[i%chars.length]; i++; },300);
    }

    // --- Chess rules ---
    function getMoves(r,c) {
      let raw=basicMoves(r,c);
      return raw.filter(m=>!leavesKingInCheck(r,c,m[0],m[1]));
    }

    function basicMoves(r,c) {
      let p=board[r][c]; if (p===".") return [];
      let moves=[], dirs, r2,c2;
      let isWhite=p===p.toUpperCase();
      switch(p.toLowerCase()) {
        case "p": // pawns
          let dir=isWhite?-1:1;
          if (inside(r+dir,c)&&board[r+dir][c]===".") {
            moves.push([r+dir,c]);
            if ((isWhite&&r===6)||(!isWhite&&r===1))
              if (board[r+2*dir][c]===".") moves.push([r+2*dir,c]);
          }
          for (let dc of [-1,1]) {
            r2=r+dir; c2=c+dc;
            if (inside(r2,c2)&&board[r2][c2]!=="."
              && isWhite!== (board[r2][c2]===board[r2][c2].toUpperCase())) moves.push([r2,c2]);
          }
          break;
        case "n":
          for (let d of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
            r2=r+d[0]; c2=c+d[1];
            if (inside(r2,c2) && (board[r2][c2]==="."||isWhite!==(board[r2][c2]===board[r2][c2].toUpperCase()))) moves.push([r2,c2]);
          }
          break;
        case "b":
          dirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
          slide(r,c,dirs,isWhite,moves); break;
        case "r":
          dirs=[[1,0],[-1,0],[0,1],[0,-1]];
          slide(r,c,dirs,isWhite,moves); break;
        case "q":
          dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
          slide(r,c,dirs,isWhite,moves); break;
        case "k":
          for (let dr=-1;dr<=1;dr++) for (let dc=-1;dc<=1;dc++) {
            if (dr===0&&dc===0) continue;
            r2=r+dr;c2=c+dc;
            if (inside(r2,c2)&&(board[r2][c2]==="."||isWhite!==(board[r2][c2]===board[r2][c2].toUpperCase()))) moves.push([r2,c2]);
          }
          break;
      }
      return moves;
    }

    function slide(r,c,dirs,isWhite,moves){
      for (let d of dirs) {
        let r2=r+d[0], c2=c+d[1];
        while(inside(r2,c2)) {
          if (board[r2][c2]===".") moves.push([r2,c2]);
          else {
            if (isWhite!==(board[r2][c2]===board[r2][c2].toUpperCase())) moves.push([r2,c2]);
            break;
          }
          r2+=d[0]; c2+=d[1];
        }
      }
    }

    function inside(r,c){return r>=0&&r<8&&c>=0&&c<8;}

    function findKing(isWhite) {
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (isWhite&&p==="K") return [r,c];
        if (!isWhite&&p==="k") return [r,c];
      }
      return null;
    }

    function inCheck(color) {
      let king=findKing(color==="white"); if (!king) return true;
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (p===".") continue;
        let enemy=(color==="white"?p===p.toLowerCase():p===p.toUpperCase());
        if (enemy) {
          if (basicMoves(r,c).some(m=>m[0]===king[0]&&m[1]===king[1])) return true;
        }
      }
      return false;
    }

    function leavesKingInCheck(r1,c1,r2,c2){
      let save1=board[r1][c1], save2=board[r2][c2];
      board[r2][c2]=save1; board[r1][c1]=".";
      let res=inCheck(save1===save1.toUpperCase()?"white":"black");
      board[r1][c1]=save1; board[r2][c2]=save2;
      return res;
    }

    function checkmate(color) {
      if (!inCheck(color)) return false;
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (p===".") continue;
        if ((color==="white"&&p===p.toUpperCase())||
            (color==="black"&&p===p.toLowerCase())) {
          if (getMoves(r,c).length>0) return false;
        }
      }
      return true;
    }

    // --- Bot engine ---
    function botMove() {
      let moves=[];
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (p!=="."&&p===p.toLowerCase()){
          getMoves(r,c).forEach(m=>moves.push([r,c,m[0],m[1]]));
        }
      }
      if (moves.length===0) return;
      let move;
      if (mode==="easy") move=randomMove(moves);
      else if (mode==="intermediate") move=captureBias(moves);
      else if (mode==="medium") move=greedyMove(moves);
      else {
        let depth=2;
        if (mode==="hard") depth=3;
        if (mode==="insane") depth=4;
        if (mode==="genius") depth=5;
        move=minimaxRoot(depth,false);
      }
      makeMove(move[0],move[1],move[2],move[3]);
    }

    // --- Bot helpers ---
    function randomMove(moves){ return moves[Math.floor(Math.random()*moves.length)]; }
    function captureBias(moves){ return moves.find(m=>board[m[2]][m[3]]!==".")||randomMove(moves); }
    function greedyMove(moves){
      let best=null,bestScore=-999;
      for (let m of moves){
        let captured=board[m[2]][m[3]];
        let score=pieceValue(captured);
        if (score>bestScore){best=m;bestScore=score;}
      }
      return best||randomMove(moves);
    }

    function pieceValue(p){
      switch(p.toLowerCase()){
        case "p":return 100; case "n":case "b":return 300;
        case "r":return 500; case "q":return 900;
        case "k":return 10000; default:return 0;
      }
    }

    // --- Minimax with alpha-beta ---
    function evaluateBoard(){
      let score=0;
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (p===".") continue;
        let val=pieceValue(p);
        if (p===p.toUpperCase()) score+=val;
        else score-=val;
      }
      return score;
    }

    function minimaxRoot(depth,isMaximizing){
      let moves=[];
      for (let r=0;r<8;r++)for(let c=0;c<8;c++){
        let p=board[r][c];
        if (p!=="."&&p===p.toLowerCase()){
          getMoves(r,c).forEach(m=>moves.push([r,c,m[0],m[1]]));
        }
      }
      let bestMove, bestVal=-999999;
      for (let m of moves){
        let [r1,c1,r2,c2]=m;
        let captured=board[r2][c2];
        board[r2][c2]=board[r1][c1]; board[r1][c1]=".";
        let val=minimax(depth-1,true,-999999,999999);
        board[r1][c1]=board[r2][c2]; board[r2][c2]=captured;
        if (val>bestVal){bestVal=val; bestMove=m;}
      }
      return bestMove;
    }

    function minimax(depth,isMaximizing,alpha,beta){
      if (depth===0) return evaluateBoard();
      if (isMaximizing){ // white
        let maxEval=-999999;
        for (let r=0;r<8;r++)for(let c=0;c<8;c++){
          let p=board[r][c];
          if (p!=="."&&p===p.toUpperCase()){
            for (let m of getMoves(r,c)){
              let [r2,c2]=m; let captured=board[r2][c2];
              board[r2][c2]=board[r][c]; board[r][c]=".";
              let eval=minimax(depth-1,false,alpha,beta);
              board[r][c]=board[r2][c2]; board[r2][c2]=captured;
              maxEval=Math.max(maxEval,eval);
              alpha=Math.max(alpha,eval);
              if (beta<=alpha) return maxEval;
            }
          }
        }
        return maxEval;
      } else { // black
        let minEval=999999;
        for (let r=0;r<8;r++)for(let c=0;c<8;c++){
          let p=board[r][c];
          if (p!=="."&&p===p.toLowerCase()){
            for (let m of getMoves(r,c)){
              let [r2,c2]=m; let captured=board[r2][c2];
              board[r2][c2]=board[r][c]; board[r][c]=".";
              let eval=minimax(depth-1,true,alpha,beta);
              board[r][c]=board[r2][c2]; board[r2][c2]=captured;
              minEval=Math.min(minEval,eval);
              beta=Math.min(beta,eval);
              if (beta<=alpha) return minEval;
            }
          }
        }
        return minEval;
      }
    }

    reset();
  </script>
</body>
  </html>


